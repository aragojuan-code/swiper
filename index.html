<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Swiper – Historia de 4 mundos</title>
<meta name="theme-color" content="#0b0f14"/>
<link rel="icon" href="data:,">
<style>
 :root{
  --bg:#0b0f14; --panel:#101722; --ink:#e6eef7; --muted:#9fb3c9;
  --shadow:rgba(0,0,0,.5);
  --card-w:min(92vw,520px); --ratio:1.25; --card-h:calc(var(--card-w)*var(--ratio));
  --radius:16px;
  /* ↑ subimos la altura para que quepan dos líneas sin cortar */
  --choices-h:96px;
}

/* Descripción: deja hueco extra para las decisiones más altas */
.text{
  position:absolute; left:0; right:0; bottom:calc(var(--choices-h) + 16px);
  padding:14px 16px; font-size:15px; line-height:1.4; color:#e9f1fb;
  background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));
}

/* Decisiones SOLO texto (no clicables) */
.choices{
  position:absolute; left:14px; right:14px; bottom:10px;
  min-height:var(--choices-h);
  display:flex; gap:12px; align-items:stretch; justify-content:space-between;
  pointer-events:none;
}

/* Contenedor de cada opción */
.choice{
  flex:1; display:flex; align-items:center; gap:8px;
  padding:12px 14px; border:1px solid rgba(255,255,255,.08); border-radius:14px;
  background:rgba(255,255,255,.06); backdrop-filter:blur(4px);
  min-width:0; /* importante para que permita wraps */
}

/* Texto completo (sin elipsis) */
.choice .opt{
  font-weight:700; font-size:15px; line-height:1.25;
  white-space:normal; overflow:visible; text-overflow:clip;
}

/* Flecha */
.choice .arr{ opacity:.9; font-size:16px; flex:0 0 auto }

/* Alineaciones: flecha a cada extremo */
.choice-left{ justify-content:flex-start; text-align:left; }
.choice-left .arr{ order:-1; margin-right:8px; }  /* flecha a la IZQ */

.choice-right{ justify-content:flex-end; text-align:right; }
.choice-right .arr{ order:1; margin-left:8px; }   /* flecha a la DER */

/* (Opcional) en pantallas muy estrechas, una opción por fila */
@media (max-width:360px){
  .choices{ flex-direction:column; gap:8px; }
  :root{ --choices-h:120px; }
}


  .hint{position:absolute;top:8px;left:8px;font-size:11px;color:#c9d5e7;background:rgba(0,0,0,.35);padding:6px 8px;border-radius:10px}
  .toast{
    position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:4;
    background:#0e1520;border:1px solid rgba(255,255,255,.08);color:#dfe8f5;
    padding:10px 12px;border-radius:12px;font-size:13px;opacity:0;pointer-events:none;box-shadow:0 10px 30px var(--shadow);
  }
  .toast.show{opacity:1;transition:opacity .25s}

  /* Video fondo */
  .bg{position:fixed;inset:0;z-index:0;overflow:hidden;pointer-events:none}
  .bg video{position:absolute;width:100%;height:100%;object-fit:cover;filter:brightness(.9) saturate(.95) contrast(1)}
  .bg::after{content:"";position:absolute;inset:0;background:radial-gradient(ellipse at 50% 110%, rgba(0,0,0,.55), rgba(0,0,0,.15) 50%, rgba(0,0,0,.05) 70%)}
  .veil{position:fixed;inset:0;background:linear-gradient(to bottom, rgba(5,8,12,.4), rgba(5,8,12,.25));z-index:0}
</style>
</head>
<body>
<div class="bg"><video id="bgvid" playsinline muted loop autoplay></video></div>
<div class="veil"></div>

<div class="wrap">
  <header>
    <div class="topbar"><span class="pill" id="worldTag">—</span><span class="crumbs" id="crumbs">—</span></div>
    <div class="kb"></div>
  </header>
  <div class="board" id="board"></div>
  <div class="toast" id="toast"></div>
</div>

<script>
/* ========= CONFIG ========= */
const PROJECT_REF = "rdoivmucgucouauyqdos";
const DATA_BASE   = `https://${PROJECT_REF}.supabase.co/storage/v1/object/public/data`;
const IMG_BASE    = `https://${PROJECT_REF}.supabase.co/storage/v1/object/public/swiper`;
const WORLD_BASE  = `https://${PROJECT_REF}.supabase.co/storage/v1/object/public/worlds`;
const URL_CARDS   = `${DATA_BASE}/cards.json`;
const URL_IMAGES  = `${DATA_BASE}/images.json`;
const URL_WORLDS  = `${DATA_BASE}/worlds.json`;

/* ========= UTILS ========= */
const slug = s => String(s||"").normalize("NFD").replace(/[\u0300-\u036f]/g,"").trim();
const byId = (arr, key="id") => Object.fromEntries(arr.map(o => [o[key], o]));

/* ========= STATE ========= */
const state = { cards:[], map:{}, images:[], worlds:{}, world:"", order:[], index:0 };

/* ========= LOAD ========= */
async function loadJSON(url){
  const r = await fetch(url);
  if(!r.ok){ throw new Error(`No pude cargar ${url} (HTTP ${r.status})`); }
  const ct = r.headers.get("content-type")||"";
  return ct.includes("application/json") ? r.json() : JSON.parse(await r.text());
}
async function boot(){
  const [cards, imgs, wlds] = await Promise.all([
    loadJSON(URL_CARDS), loadJSON(URL_IMAGES).catch(()=>[]), loadJSON(URL_WORLDS).catch(()=>({}))
  ]);
  const src = Array.isArray(cards) ? cards : (cards.data||[]);
  state.cards = src.map(normalizeCard);
  state.map   = byId(state.cards);
  state.images = Array.isArray(imgs) ? imgs : (imgs.data||[]);
  state.worlds = wlds || {};

  state.world = state.cards[0]?.mundo || "El Bosque de los Susurros";
  rebuildOrderForWorld(state.world);
  setWorldBackground(state.world);
  goToId(state.order[0]);
}

function normalizeCard(o){
  // acepta tus nombres de clave: opcion_izquierda / resultado_izquierda / ...
  const pick = (obj, keys) => keys.find(k=>k in obj) && obj[keys.find(k=>k in obj)];
  return {
    mundo:   pick(o,["Mundo","mundo"]) || "",
    id:      String(pick(o,["ID / Nombre","id","ID","Nombre"])||""),
    tipo:   (pick(o,["Tipo","tipo"]) || "decision").toLowerCase(),
    texto:   pick(o,["Texto (breve)","texto"]) || "",
    optL:    pick(o,["Opción ← (izquierda)","optL","opcion_izquierda"]) || "",
    resL:    pick(o,["Resultado ←","resL","resultado_izquierda"]) || "",
    optR:    pick(o,["Opción → (derecha)","optR","opcion_derecha"]) || "",
    resR:    pick(o,["Resultado →","resR","resultado_derecha"]) || "",
    image_file: o.image_file || o.imageFilename || null,
  };
}

function rebuildOrderForWorld(worldName){
  const list = state.cards.filter(c => c.mundo === worldName);
  list.sort((a,b)=> a.id.localeCompare(b.id,'es',{numeric:true,sensitivity:'base'}));
  state.order = list.map(c => c.id);
  state.index = 0;
}

/* ========= BG VIDEO ========= */
function setWorldBackground(worldName){
  const vid = document.getElementById("bgvid");
  const url = state.worlds[worldName] || guessWorldUrl(worldName);
  if(!url) return;
  if (vid.src !== url){ vid.src = url; vid.play?.().catch(()=>{}); }
}
document.addEventListener("touchend", ()=>{ document.getElementById("bgvid")?.play?.().catch(()=>{}); }, {once:true});
function guessWorldUrl(worldName){
  const k = slug(worldName).toLowerCase();
  if (k.includes("bosque"))   return `${WORLD_BASE}/bosque_bg.mp4`;
  if (k.includes("castillo")) return `${WORLD_BASE}/castillo_bg.mp4`;
  if (k.includes("monstruo")) return `${WORLD_BASE}/monstruo_bg.mp4`;
  if (k.includes("princesa")) return `${WORLD_BASE}/princesa_bg.mp4`;
  return "";
}

/* ========= RENDER ========= */
function imageUrlFor(card){
  if (card.image_file) return `${IMG_BASE}/${card.image_file}`;
  const idKey = slug(card.id).toLowerCase().replace(/[^\w]+/g,"");
  if (state.images.length){
    const hit = state.images.find(x=>{
      const fname = (x.filename||x.file||"").toLowerCase().replace(/[^\w]+/g,"");
      return fname.includes(idKey);
    });
    // PRIORIDAD al filename (tu image_url tiene el dominio mal escrito)
    if (hit?.filename)  return `${IMG_BASE}/${hit.filename}`;
    if (hit?.image_url) return hit.image_url;
    if (hit?.url)       return hit.url;
  }
  const fname = `${slug(card.mundo).toLowerCase().replace(/[^\w]+/g,"_")}_${slug(card.id).toLowerCase().replace(/[^\w]+/g,"_")}.png`;
  return `${IMG_BASE}/${fname}`;
}

function renderCard(card){
  const board = document.getElementById("board");
  board.innerHTML = "";

  const wrap = el("div","card");
  const img  = el("img"); img.src = imageUrlFor(card); img.alt = "";
  const fade = el("div","fade");
  const text = el("div","text"); text.textContent = card.texto || "";

  const hint = el("div","hint"); hint.textContent = "Desliza ← / →";

  // Decisiones solo texto
  const choices = el("div","choices");
  const chL = el("div","choice");
  chL.innerHTML = `<span class="arr">←</span><span class="opt">${card.optL || labelFromResult(card.resL,"Izquierda")}</span>`;
  const chR = el("div","choice");
  chR.innerHTML = `<span class="arr">→</span><span class="opt">${card.optR || labelFromResult(card.resR,"Derecha")}</span>`;
  choices.append(chL,chR);

  wrap.append(img, fade, text, choices, hint);
  board.append(wrap);

  enableSwipe(wrap, dir=>{
    if(dir==="left")  applyResult(card.resL||"", "left");
    if(dir==="right") applyResult(card.resR||"", "right");
  });

  document.getElementById("worldTag").textContent = state.world;

  // Auto en transiciones
  if (card.tipo === "transition"){
    setTimeout(()=>{
      const next = pickAutoResult(card);
      applyResult(next.cmd, next.dir);
    }, 700);
  }
}

function labelFromResult(res, fallback){
  const p = parseResult(res);
  if (p.type==="finish")  return "Final";
  if (p.type==="restart") return "Reiniciar";
  if (p.type==="pass")    return "Cambiar de mundo";
  if (p.type==="goto")    return "Avanzar";
  return fallback;
}

function pickAutoResult(card){
  const cands = [card.resL, card.resR].filter(Boolean);
  for(const r of cands){
    const p = parseResult(r);
    if(["restart","pass","goto","finish"].includes(p.type)) return {cmd:r, dir:"right"};
  }
  return {cmd:"REINICIA → 1", dir:"right"};
}

/* ========= NAV + PARSER ========= */
function goToId(id){
  const card = state.map[id];
  if(!card){ toast(`No encuentro la carta "${id}"`); return; }
  if (card.mundo !== state.world){
    state.world = card.mundo; rebuildOrderForWorld(state.world); setWorldBackground(state.world);
  }
  state.index = state.order.indexOf(card.id);
  if (state.index < 0){ state.order.push(card.id); state.index = state.order.length-1; }
  renderCard(card);
}

function restartWorld(){
  rebuildOrderForWorld(state.world);
  setWorldBackground(state.world);
  goToId(state.order[0]);
}

/* Captura solo el primer token [A-Za-z0-9_] tras →/LOOP (ignora emojis, paréntesis, textos extra) */
function parseResult(s){
  const clean = slug(s||"");

  if (/fin\s*del\s*juego/i.test(clean)) return {type:"finish"};
  if (/reinicia/i.test(clean)) return {type:"restart"};

  // PASS → CASTILLO / PASS → MUNDO 3
  let m = clean.match(/pass.*?→\s*([A-Za-z0-9_]+)/i);
  if (m) return {type:"pass", to: m[1]};

  // LOOP → 2B / LOOP a 1
  m = clean.match(/loop\s*(?:→|a)\s*([A-Za-z0-9_]+)/i);
  if (m) return {type:"goto", id: normalizeShortId(m[1])};

  // → 3D_end_savia (transition)  -> 3D_end_savia
  m = clean.match(/→\s*([A-Za-z0-9_]+)/);
  if (m) return {type:"goto", id: normalizeShortId(m[1])};

  return {type:"noop"};
}

function normalizeShortId(token){
  const t = String(token||"").toLowerCase();
  if (t.startsWith("carta_")) return token;
  const keys = Object.keys(state.map);
  const hit = keys.find(k=>{
    const kk = k.toLowerCase();
    return kk.endsWith(`_${t}`) || kk.includes(`_${t}_`) || kk===t;
  });
  return hit || token;
}

function canonicalWorldName(token){
  const k = slug(token).toLowerCase();
  if (k.includes("castillo")) return "El Castillo de los Espejos";
  if (k.includes("monstruo")) return "El Monstruo Final";
  if (k.includes("princesa")) return "La Princesa Durmiente";
  if (k.includes("bosque") || k.includes("mundo_1") || k==="1") return "El Bosque de los Susurros";
  const worlds = [...new Set(state.cards.map(c=>c.mundo))];
  return worlds.find(w => slug(w).toLowerCase().includes(k)) || state.world;
}

function applyResult(res, dir){
  const p = parseResult(res);
  switch(p.type){
    case "finish":
      toast("FIN DEL JUEGO ✨", 900);
      setTimeout(()=>{ state.world="El Bosque de los Susurros"; restartWorld(); }, 800);
      break;
    case "pass":
      state.world = canonicalWorldName(p.to);
      rebuildOrderForWorld(state.world);
      setWorldBackground(state.world);
      goToId(state.order[0]);
      break;
    case "restart":
      restartWorld(); break;
    case "goto":
      goToId(p.id); break;
    default:
      toast("…", 500);
  }
}

/* ========= SWIPE ========= */
function enableSwipe(el, cb){
  let startX=0, startY=0, dx=0, dy=0, active=false;
  const onDown = (e)=>{ active=true; const p=point(e); startX=p.x; startY=p.y; dx=dy=0; el.setPointerCapture?.(e.pointerId); };
  const onMove = (e)=>{ if(!active) return; const p=point(e); dx=p.x-startX; dy=p.y-startY;
    el.style.transform = `translate3d(${dx}px, ${dy*0.2}px, 0) rotate(${dx*0.05}deg)`; el.style.opacity = String(Math.max(.35,1-Math.abs(dx)/500)); };
  const onUp = ()=>{ if(!active) return; active=false; const th=60; if (dx<-th) cb("left"); else if(dx>th) cb("right");
    el.style.transition="transform .18s ease, opacity .18s ease"; el.style.transform="translate3d(0,0,0) rotate(0)"; el.style.opacity="1"; setTimeout(()=> el.style.transition="", 200); };
  el.addEventListener("pointerdown", onDown);
  window.addEventListener("pointermove", onMove);
  window.addEventListener("pointerup", onUp);
  window.addEventListener("pointercancel", onUp);
}
function point(e){ return {x: e.clientX ?? (e.touches?.[0]?.clientX||0), y: e.clientY ?? (e.touches?.[0]?.clientY||0)}; }

/* ========= MISC ========= */
function el(tag,cls){ const n=document.createElement(tag); if(cls) n.className=cls; return n; }
function toast(msg,ms=1400){ const t=document.getElementById("toast"); t.textContent=msg; t.classList.add("show"); clearTimeout(t._h); t._h=setTimeout(()=>t.classList.remove("show"),ms); }
window.addEventListener("keydown",(e)=>{
  const cur=state.map[state.order[state.index]]; if(!cur) return;
  if(e.key==="ArrowLeft")  applyResult(cur.resL||"","left");
  if(e.key==="ArrowRight") applyResult(cur.resR||"","right");
  if(e.key.toLowerCase()==="r") restartWorld();
});

/* ========= START ========= */
boot().catch(err=>{ console.error(err); toast("Error cargando datos"); });
</script>
</body>
</html>
